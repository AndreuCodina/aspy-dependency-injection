{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#what-is-dependency-injection","title":"What is Dependency Injection","text":"<p>Dependency Injection (DI) is a design pattern where a class receives the objects it depends on from the outside, instead of creating them itself. This separates object construction from object usage, making code easier to test and change.</p>"},{"location":"#benefits-of-dependency-injection","title":"Benefits of Dependency Injection","text":"<ul> <li>Loose coupling</li> </ul> <p>Easily extend or change the functionality of a system by combining the components in a different way.</p> <ul> <li>Improved testability</li> </ul> <p>Dependencies can be replaced with mocks, stubs, or simple test doubles, enabling fast and isolated unit tests.</p> <ul> <li>Better maintainability</li> </ul> <p>Object creation, configuration, and business logic are clearly separated, making the codebase easier to understand and evolve.</p> <ul> <li>Controlled variability</li> </ul> <p>Different behaviors can be provided at runtime (for example, real vs. fake dependencies) without modifying the consuming code.</p> <ul> <li>Centralized wiring</li> </ul> <p>Object creation and dependency wiring live in one place (the composition root), keeping domain and application logic clean.</p> <p>In short, DI does not magically decouple behavior, but it decouples construction, which already brings significant practical benefits in Python.</p>"},{"location":"#features-of-wirio","title":"Features of Wirio","text":"<ul> <li>Use it everywhere: Use dependency injection in web servers, background tasks, console applications, Jupyter notebooks, tests, etc.</li> <li>Lifetimes: <code>Singleton</code> (same instance per application), <code>Scoped</code> (same instance per HTTP request scope) and <code>Transient</code> (different instance per resolution).</li> <li>FastAPI integration out of the box, and pluggable to any web framework.</li> <li>Automatic resolution and disposal: Automatically resolve constructor parameters and manage async and non-async context managers. It's no longer our concern to know how to create or dispose services.</li> <li>Clear design inspired by one of the most used and battle-tested DI libraries, adding async-native support, important features and good defaults.</li> <li>Centralized configuration: Register all services in one place using a clean syntax, and without decorators.</li> <li>ty and Pyright strict compliant.</li> </ul>"},{"location":"testing/","title":"Testing","text":""},{"location":"testing/#quickstart","title":"Quickstart","text":"<p>We have to use the service provider to resolve the services we want to test. The way to get it depends on the type of application we are testing.</p> FastAPIConsole application <p>The way FastAPI has to execute code before running the tests is different from a console application. It uses its own test client that creates an application instance for each test.</p> <p>We have to import the services from the <code>app</code> singleton of <code>main.py</code>, and create a fixture to inject the service provider.</p> <pre><code>from main import app\nfrom wirio.integrations.fastapi import get_service_provider\n\n@pytest.fixture\ndef service_provider() -&gt; Generator[ServiceProvider]:\n    with TestClient(app):\n        yield get_service_provider(app)\n</code></pre> <p>We have to import the services from <code>main.py</code>. To do that, we can create the function <code>configure_services</code> (or move the <code>services</code> variable outside the <code>main</code> function).</p> <pre><code>def configure_services() -&gt; ServiceCollection:\n    services = ServiceCollection()\n    ...\n\n    return services\n</code></pre> <p>The next step is creating a fixture to inject the service provider.</p> <pre><code>from main import configure_services\n\n@pytest.fixture\nasync def service_provider() -&gt; AsyncGenerator[ServiceProvider]:\n    services = configure_services()\n\n    async with services.build_service_provider() as service_provider:\n        yield service_provider\n</code></pre> <p>And then we can inject it into our tests and resolve the services.</p> <pre><code>async def test_create_user(service_provider: ServiceProvider) -&gt; None:\n    user_service = await service_provider.get_required_service(UserService)\n\n    await user_service.create_user()\n</code></pre>"},{"location":"testing/#override-services","title":"Override services","text":"<p><code>UserService</code> could have the dependency <code>EmailService</code>, that sends real emails. During testing, we want to replace it with a mock implementation that doesn't send real emails.</p> <p>To replace a service during testing, we can use the <code>override_service</code> and <code>override_keyed_service</code> methods provided by <code>ServiceProvider</code>. This allows us to temporarily replace a service for the duration of context manager block.</p> <pre><code>async def test_create_user(service_provider: ServiceProvider, mocker: MockerFixture) -&gt; None:\n    email_service_mock = mocker.create_autospec(EmailService, instance=True)\n\n    with service_provider.override_service(EmailService, email_service_mock):\n        user_service = await service_provider.get_required_service(UserService)\n\n        await user_service.create_user()\n</code></pre>"},{"location":"testing/#globally-override-services","title":"Globally override services","text":"<p>We can also override a service for all tests by modifying the fixture that provides the <code>ServiceProvider</code> instance. This is useful when we want to use a mock for a service across multiple tests, or all tests.</p> FastAPIConsole application <pre><code>@pytest.fixture\ndef service_provider(mocker: MockerFixture) -&gt; Generator[ServiceProvider]:\n    with TestClient(app):\n        service_provider = get_service_provider(app)\n        email_service_mock = mocker.create_autospec(EmailService, instance=True)\n\n        with service_provider.override_service(EmailService, email_service_mock):\n            yield service_provider\n</code></pre> <pre><code>@pytest.fixture\nasync def service_provider(mocker: MockerFixture) -&gt; AsyncGenerator[ServiceProvider]:\n    services = configure_services()\n\n    async with services.build_service_provider() as service_provider:\n        email_service_mock = mocker.create_autospec(EmailService, instance=True)\n\n        with service_provider.override_service(EmailService, email_service_mock):\n            yield service_provider\n</code></pre>"},{"location":"testing/#servicecollection-registration","title":"ServiceCollection registration","text":"<p>The context manager approach is straightforward, but if we want to test a more complex scenario, we can directly register the mock implementation in the <code>ServiceCollection</code> before building the <code>ServiceProvider</code>. This way, the mock will be used whenever <code>EmailService</code> is resolved.</p> <pre><code>@pytest.fixture\nasync def service_provider(mocker: MockerFixture) -&gt; AsyncGenerator[ServiceProvider]:\n    services = configure_services()\n    email_service_mock = mocker.create_autospec(EmailService, instance=True)\n    services.add_singleton(EmailService, email_service_mock)\n\n    async with services.build_service_provider() as service_provider:\n        yield service_provider\n</code></pre> <p>Remember that if <code>EmailService</code> is already registered, registering it again means the last registration will be used when resolving the service.</p> <p>Note: Another strategy could be not to register <code>EmailService</code> in local, and register it depending on the environment.</p>"},{"location":"advanced-features/auto-activated-services/","title":"Auto-activated services","text":""},{"location":"advanced-features/auto-activated-services/#overview","title":"Overview","text":"<p>By default, services are instantiated/activated lazily, i.e., when they are requested. This behavior enables lifetime management and reduces startup time.</p> <p>However, some singleton services need to be instantiated/activated before the application starts handling requests (what we call auto-activation), so that our customers don't experience delayed or timed-out requests. Some examples are machine learning models, database connection pools, telemetry collectors, and background tasks.</p> <p>Example scenario: In our FastAPI application, we have to load a machine learning model, so we add it as an auto-activated service. If we have one cloud instance for the API, when we deploy a new version, the new one isn't replaced until the model is loaded in memory, ensuring that all requests are served without delays or time-out errors. If we have autoscaling enabled, new instances aren't added to the load balancer until the model is loaded.</p>"},{"location":"advanced-features/auto-activated-services/#register-auto-activated-singletons","title":"Register auto-activated singletons","text":"<p>Use <code>add_auto_activated_singleton()</code> or <code>add_auto_activated_keyed_singleton()</code> to register singletons or keyed singletons as auto-activated services. The accepted parameters are identical to <code>add_singleton()</code> and <code>add_keyed_singleton()</code>, respectively.</p> <pre><code>services.add_auto_activated_singleton(MachineLearningModel)\n</code></pre> <p>Auto-activation of keyed services is especially useful when a subset of tenants or regions need warm caches or long-lived sockets before they receive traffic.</p> <pre><code>services.add_auto_activated_keyed_singleton(\"west-us\", DataPlaneClient, RegionalClient)\n</code></pre>"},{"location":"advanced-features/auto-activated-services/#upgrade-existing-registrations","title":"Upgrade existing registrations","text":"<p>If a singleton is already registered, we can enable auto-activation for it via <code>enable_singleton_auto_activation</code> or <code>enable_keyed_singleton_auto_activation</code>.</p> <pre><code># Original registration\nservices.add_singleton(BackgroundPublisher)\nservices.add_keyed_singleton(\"us-east\", DataPlaneClient, RegionalClient)\n\n# Later\nservices.enable_singleton_auto_activation(BackgroundPublisher)\nservices.enable_keyed_singleton_auto_activation(\"us-east\", DataPlaneClient)\n</code></pre>"},{"location":"advanced-features/auto-activated-services/#when-to-auto-activate","title":"When to auto-activate","text":"<ul> <li>Prime caches, long-lived connections, or periodic tasks that must run before the first request.</li> <li>Fail-fast during startup by surfacing dependency errors.</li> <li>Avoid auto-activation for expensive workloads that are rarely used or that scale with tenant count; lazily resolving them keeps startup predictable.</li> <li>Combine with application health checks to make sure all auto-activated services are ready before serving traffic.</li> </ul>"},{"location":"advanced-features/get-all-services-of-a-type/","title":"Get all services of a type","text":"<p>Sometimes we want to resolve all services registered for a given type. For example, we might want to resolve all implementations of an interface.</p> <pre><code>services.add_transient(NotificationService, EmailService)\nservices.add_transient(NotificationService, SmsService)\nservices.add_transient(NotificationService, WhatsAppService)\n\n\nclass UserService:\n    def __init__(\n        self,\n        notification_services: Sequence[NotificationService]\n    ) -&gt; None:\n        self.notification_services = notification_services\n</code></pre> <p>We could also resolve all implementations with a specific key.</p> <pre><code>services.add_keyed_transient(\"key\", EmailService)\nservices.add_keyed_transient(\"key\", SmsService)\nservices.add_keyed_transient(\"key\", WhatsAppService)\n\n\nclass UserService:\n    def __init__(\n        self,\n        notification_services: Annotated[\n            Sequence[NotificationService], FromKeyedServices(\"key\")\n        ]\n    ) -&gt; None:\n        self.notification_services = notification_services\n</code></pre> <p>Using a <code>ServiceProvider</code>, we can resolve all services of a type using <code>get_services</code> and <code>get_keyed_services</code>.</p>"},{"location":"advanced-features/interfaces-and-abstract-classes/","title":"Interfaces &amp; abstract classes","text":"<p>We can register a service by specifying both the service type (interface / abstract class) and the implementation type (concrete class). This is useful when we want to inject services using abstractions.</p> <pre><code>class NotificationService(ABC):\n    @abstractmethod\n    async def send_notification(self, user_id: str, message: str) -&gt; None:\n        ...\n\n\nclass EmailService(NotificationService):\n    @override\n    async def send_notification(self, user_id: str, message: str) -&gt; None:\n        pass\n\n\nclass UserService:\n    def __init__(self, notification_service: NotificationService) -&gt; None:\n        self.notification_service = notification_service\n\n    async def create_user(self, email: str) -&gt; None:\n        user = self.create_user(email)\n        await self.notification_service.send_notification(user.id, \"Welcome to our service!\")\n\n\nservices.add_transient(NotificationService, EmailService)\n</code></pre>"},{"location":"advanced-features/keyed-services/","title":"Keyed services","text":""},{"location":"advanced-features/keyed-services/#overview","title":"Overview","text":"<p>Keyed services let us register multiple implementations of the same abstraction and pick the one we need at resolution time by supplying a key. They are ideal for multi-tenant workloads, per-region clients, feature flags, or whenever a single interface must be backed by different resources.</p>"},{"location":"advanced-features/keyed-services/#introductory-example","title":"Introductory example","text":"<p>We have two implementations of <code>NotificationService</code>: one that sends emails and another that sends push notifications. We want to be able to choose which implementation to use when injecting <code>NotificationService</code> into <code>UserService</code>.</p> <p>We can use <code>add_keyed_transient</code>, <code>add_keyed_scoped</code>, or <code>add_keyed_singleton</code> to bind an implementation to a specific key.</p> <pre><code>class NotificationService(ABC):\n    @abstractmethod\n    async def send_notification(self, recipient: str, message: str) -&gt; None:\n        ...\n\n\nclass EmailService(NotificationService):\n    @override\n    async def send_notification(self, recipient: str, message: str) -&gt; None:\n        pass\n\n\nclass PushNotificationService(NotificationService):\n    @override\n    async def send_notification(self, recipient: str, message: str) -&gt; None:\n        pass\n\n\nclass UserService:\n    def __init__(\n        self,\n        notification_service: Annotated[NotificationService, FromKeyedServices(\"email\")],\n    ) -&gt; None:\n        self.notification_service = notification_service\n\n    async def create_user(self, email: str) -&gt; None:\n        user = self.create_user(email)\n        await self.notification_service.send_notification(user.id, \"Welcome to our service!\")\n\n\nservices.add_keyed_transient(\"email\", NotificationService, EmailService)\nservices.add_keyed_transient(\"push\", NotificationService, PushNotificationService)\n</code></pre> <p>In the example we're using a key of type string, but we can use any type (enums, integers, etc.).</p>"},{"location":"advanced-features/keyed-services/#example-with-feature-flags","title":"Example with feature flags","text":"<pre><code>class OrderService:\n    def __init__(\n        self,\n        feature_manager: FeatureManager,\n        service_provider: BaseServiceProvider\n    ) -&gt; None:\n        self.feature_manager = feature_manager\n        self.service_provider = service_provider\n\n\n    async def calculate_price(self, product: Product) -&gt; Decimal:\n        pricing_service = (\n            await self.service_provider.get_required_keyed_service(\"new\", PricingService)\n            if await self.feature_manager.is_enabled(\"NewPricing\")\n            else await self.service_provider.get_required_keyed_service(\"legacy\", PricingService)\n        )\n        return pricing_service.calculate_price(product)\n\n\nservices.add_keyed_transient(\"new\", PricingService, NewPricingService)\nservices.add_keyed_transient(\"legacy\", PricingService, LegacyPricingService)\n</code></pre> <p>Or we can also use a factory to encapsulate the logic and a transient registration.</p>"},{"location":"advanced-features/keyed-services/#register-multiple-and-dynamic-keyed-services","title":"Register multiple and dynamic keyed services","text":"<p>Factories receive the requested key as their first argument so we can flow it into the created object when needed.</p> <pre><code>def inject_principal_postgres_client(_: str | None) -&gt; PostgresClient:\n    return PostgresClient(f\"postgresql://principal1239139123213.example/db\")\n\n\ndef inject_secondary_postgres_client(_: str | None) -&gt; PostgresClient:\n    return PostgresClient(f\"postgresql://secondary9954322u3912u123.example/db\")\n\n\ndef inject_tenant_postgres_client(tenant_id: str | None) -&gt; PostgresClient:\n    return PostgresClient(f\"postgresql://{tenant_id}.example/db\")\n\n\nservices = ServiceCollection()\nservices.add_keyed_singleton(\"principal\", inject_principal_postgres_client)\nservices.add_keyed_singleton(\"secondary\", inject_secondary_postgres_client)\nservices.add_keyed_singleton(KeyedService.ANY_KEY, inject_tenant_postgres_client)\n\nasync with services.build_service_provider() as service_provider:\n    postgres_client = await service_provider.get_required_keyed_service(\n        \"principal\", PostgresClient\n    )\n</code></pre> <p>The <code>ANY_KEY</code> registration works as a fallback: any lookup that does not find a dedicated key reuses that instance.</p> <p>Passing <code>None</code> as the key resolves services that were explicitly registered with <code>None</code>, but it also falls back to the unkeyed registration of the same service type when no keyed entry exists. This makes it easy to gradually adopt keyed services without duplicating registrations.</p> <p>We can query registrations programmatically through <code>ServiceProviderIsKeyedService.is_keyed_service(key, service_type)</code> to decide when to fall back to defaults.</p>"},{"location":"advanced-features/keyed-services/#composing-services-with-fromkeyedservices","title":"Composing services with <code>FromKeyedServices</code>","text":"<p>We can inject keyed dependencies into other services via <code>typing.Annotated</code> and the <code>FromKeyedServices</code> helper:</p> <pre><code>class TenantRepository:\n    def __init__(\n        self,\n        connection: Annotated[PostgresClient, FromKeyedServices(\"tenant-1\")],\n    ) -&gt; None:\n        self.connection = connection\n</code></pre> <p><code>FromKeyedServices</code> behaves differently depending on how we call it:</p> <ul> <li><code>FromKeyedServices(\"tenant-1\")</code> resolves that exact key.</li> <li><code>FromKeyedServices(None)</code> forces the <code>None</code> key (or the unkeyed registration fallback).</li> <li><code>FromKeyedServices()</code> inherits the key that was used to resolve the parent service. This is ideal when the parent itself is keyed and we want every nested dependency to share the same key automatically.</li> </ul>"},{"location":"advanced-features/keyed-services/#receiving-the-key-inside-a-service","title":"Receiving the key inside a service","text":"<p>To know which key was requested when our service was resolved, annotate a constructor parameter with <code>ServiceKey()</code>:</p> <pre><code>from typing import Annotated\nfrom wirio.annotations import ServiceKey\n\n\nclass KeyAwareCache:\n    def __init__(self, key: Annotated[str, ServiceKey()]) -&gt; None:\n        self._cache_namespace = f\"tenant:{key}\"\n</code></pre> <p>This works only when the service is itself resolved via a key (explicitly or through inheritance). Trying to use <code>ServiceKey()</code> on an unkeyed service raises <code>CannotResolveServiceError</code>.</p>"},{"location":"advanced-features/keyed-services/#wildcard-registrations-and-caveats","title":"Wildcard registrations and caveats","text":"<ul> <li><code>KeyedService.ANY_KEY</code> lets us register a catch-all implementation but cannot be used when resolving services. Attempting to resolve with that sentinel value raises <code>KeyedServiceAnyKeyUsedToResolveServiceError</code>.</li> <li>Factories registered under <code>ANY_KEY</code> receive the requested key so they can still personalize the instance.</li> <li>Register with <code>None</code> when we want a dedicated \"default\" slot that can still be requested explicitly via <code>get_required_keyed_service(None, service_type)</code> or <code>FromKeyedServices(None)</code>.</li> </ul>"},{"location":"advanced-features/keyed-services/#best-practices","title":"Best practices","text":"<ul> <li>Pick a stable key type (string tenant IDs, enums, UUIDs) and reuse it consistently.</li> <li>Prefer inherited keys (<code>FromKeyedServices()</code>) for chains of dependent services so they all operate within the same tenant context.</li> <li>Use <code>ServiceProviderIsKeyedService</code> to guard features that require a keyed registration and to emit helpful errors during startup.</li> <li>Fall back to <code>KeyedService.ANY_KEY</code> or <code>None</code> to provide safe defaults, but keep the wildcard work lightweight to avoid becoming a hotspot.</li> </ul>"},{"location":"advanced-features/service-validation/","title":"Service validation","text":""},{"location":"advanced-features/service-validation/#overview","title":"Overview","text":"<p>Wirio validates our service graph at startup and during resolution, so that dependency issues fail fast instead of surfacing as runtime bugs. Validation is opt-in through <code>services.build_service_provider(validate_scopes=True, validate_on_build=True)</code> switches. Use them to:</p> <ul> <li>Catch missing registrations (<code>CannotResolveServiceError</code>) before the first request.</li> <li>Detect scoped services flowing into singletons (<code>ScopedInSingletonError</code>).</li> <li>Block scoped services from being resolved directly from the root provider (<code>DirectScopedResolvedFromRootError</code>, <code>ScopedResolvedFromRootError</code>).</li> </ul>"},{"location":"advanced-features/service-validation/#build-time-validation-validate_on_build","title":"Build-time validation (<code>validate_on_build</code>)","text":"<p>When <code>validate_on_build=True</code>, the provider walks every registered descriptor while entering the <code>async with services.build_service_provider()</code> context. Each failure is wrapped in an <code>ExceptionGroup</code> so we can see every misconfiguration at once.</p> <pre><code>services = ServiceCollection()\nservices.add_transient(CacheWarmer)\n\ntry:\n    async with services.build_service_provider():\n        pass\nexcept ExceptionGroup as exc:\n    for error in exc.exceptions:\n        # Inspect error.__cause__ for the original CannotResolveServiceError, etc.\n        print(error.__cause__)\n</code></pre> <p>Set <code>validate_on_build=False</code> when we prefer lazy validation.</p>"},{"location":"advanced-features/service-validation/#scope-validation-validate_scopes","title":"Scope validation (<code>validate_scopes</code>)","text":"<p>Scope validation has two layers:</p> <ol> <li>Graph inspection at build time. The call-site validator walks every service tree and raises <code>ScopedInSingletonError</code> if a singleton depends (even indirectly) on a scoped service.</li> <li>Runtime guard rails. At resolution time, the provider tracks when code tries to resolve scoped services from the root scope and raises the corresponding error.</li> </ol>"},{"location":"advanced-features/service-validation/#prevent-scoped-services-inside-singletons","title":"Prevent scoped services inside singletons","text":"<pre><code>import pytest\n\nclass TenantContext:  # Scoped\n    pass\n\nclass ReportGenerator:\n    def __init__(self, context: TenantContext) -&gt; None:\n        self.context = context\n\nservices.add_scoped(TenantContext)\nservices.add_singleton(ReportGenerator)\n\nwith pytest.raises(ExceptionGroup):\n    async with services.build_service_provider(validate_scopes=True, validate_on_build=True):\n        pass\n</code></pre> <p>Fix the dependency by either making <code>ReportGenerator</code> scoped or moving the scoped dependency behind an abstracted service that supplies per-request values lazily.</p>"},{"location":"advanced-features/service-validation/#resolve-scoped-services-using-child-scopes","title":"Resolve scoped services using child scopes","text":"<p>Valid scoped resolutions happen inside a scope created from the root provider:</p> <pre><code>async with services.build_service_provider() as service_provider:\n    async with service_provider.create_scope() as service_scope:\n        report_generator = await service_scope.get_required_service(ReportGenerator)\n</code></pre> <p>Attempting to resolve a scoped service (or something that depends on it) directly from the root scope raises <code>DirectScopedResolvedFromRootError</code> or <code>ScopedResolvedFromRootError</code>. These errors usually mean we forgot to create a scope for our background job or test.</p>"},{"location":"advanced-features/service-validation/#troubleshooting-reference","title":"Troubleshooting reference","text":"<ul> <li><code>CannotResolveServiceError</code>: register the missing dependency or adjust the constructor signature.</li> <li><code>ScopedInSingletonError</code>: change the singleton into a scoped service or extract a factory/service locator that captures scoped state per resolution.</li> <li><code>DirectScopedResolvedFromRootError</code>: create a scope via <code>provider.create_scope()</code> (or let our framework manage scopes) before resolving scoped services.</li> <li><code>ScopedResolvedFromRootError</code>: same as above, but triggered when a transient or singleton indirectly requires a scoped service from the root provider.</li> </ul>"},{"location":"advanced-features/service-validation/#putting-it-together","title":"Putting it together","text":"<ul> <li>We can disable validations selectively when we prefer lazy validation or no validation for faster startup times.</li> <li>Keeping both validation flags enabled in production\u2014together with auto-activated services\u2014provides the fastest feedback loop and guarantees that our service provider is consistent before accepting traffic.</li> </ul>"},{"location":"api-reference/base-service-provider/","title":"BaseServiceProvider","text":"<p>               Bases: <code>KeyedServiceProvider</code>, <code>ServiceScopeFactory</code>, <code>ABC</code></p> <p>Define a mechanism for retrieving a service object; that is, an object that provides custom support to other objects.</p>"},{"location":"api-reference/base-service-provider/#wirio.abstractions.base_service_provider.BaseServiceProvider.create_scope","title":"create_scope  <code>abstractmethod</code>","text":"<pre><code>create_scope() -&gt; ServiceScope\n</code></pre> <p>Create a :class:<code>ServiceScope</code> that contains a :class:<code>ServiceProvider</code> used to resolve dependencies from a newly created scope.</p>"},{"location":"api-reference/base-service-provider/#wirio.abstractions.base_service_provider.BaseServiceProvider.get_keyed_service","title":"get_keyed_service  <code>async</code>","text":"<pre><code>get_keyed_service(\n    service_key: object | None, service_type: type[TService]\n) -&gt; TService | None\n</code></pre> <p>Get service of type <code>TService</code> or return <code>None</code>.</p>"},{"location":"api-reference/base-service-provider/#wirio.abstractions.base_service_provider.BaseServiceProvider.get_keyed_services","title":"get_keyed_services  <code>async</code>","text":"<pre><code>get_keyed_services(\n    service_key: object | None, service_type: type[TService]\n) -&gt; Sequence[TService]\n</code></pre> <p>Get all services of type <code>TService</code>.</p>"},{"location":"api-reference/base-service-provider/#wirio.abstractions.base_service_provider.BaseServiceProvider.get_required_keyed_service","title":"get_required_keyed_service  <code>async</code>","text":"<pre><code>get_required_keyed_service(\n    service_key: object | None, service_type: type[TService]\n) -&gt; TService\n</code></pre> <p>Get service of type <code>TService</code> or raise an error.</p>"},{"location":"api-reference/base-service-provider/#wirio.abstractions.base_service_provider.BaseServiceProvider.get_required_service","title":"get_required_service  <code>async</code>","text":"<pre><code>get_required_service(\n    service_type: type[TService],\n) -&gt; TService\n</code></pre> <p>Get service of type <code>TService</code> or raise :class:<code>NoServiceRegisteredError</code>.</p>"},{"location":"api-reference/base-service-provider/#wirio.abstractions.base_service_provider.BaseServiceProvider.get_service","title":"get_service  <code>async</code>","text":"<pre><code>get_service(\n    service_type: type[TService],\n) -&gt; TService | None\n</code></pre> <p>Get service of type <code>TService</code> or return <code>None</code>.</p>"},{"location":"api-reference/base-service-provider/#wirio.abstractions.base_service_provider.BaseServiceProvider.get_services","title":"get_services  <code>async</code>","text":"<pre><code>get_services(\n    service_type: type[TService],\n) -&gt; Sequence[TService]\n</code></pre> <p>Get all services of type <code>TService</code>.</p>"},{"location":"api-reference/configuration_manager/","title":"ConfigurationManager","text":"<p>               Bases: <code>ConfigurationBuilder</code></p>"},{"location":"api-reference/exceptions/","title":"Exceptions","text":""},{"location":"api-reference/exceptions/#wirio.exceptions.CannotResolveParameterServiceFromImplementationFactoryError","title":"CannotResolveParameterServiceFromImplementationFactoryError","text":"<p>               Bases: <code>WirioError</code></p> <p>The exception that is thrown when a service for a parameter of an implementation factory cannot be resolved.</p>"},{"location":"api-reference/exceptions/#wirio.exceptions.CannotResolveServiceError","title":"CannotResolveServiceError","text":"<p>               Bases: <code>WirioError</code></p> <p>The exception that is thrown when a service cannot be resolved.</p>"},{"location":"api-reference/exceptions/#wirio.exceptions.CannotResolveServiceFromEndpointError","title":"CannotResolveServiceFromEndpointError","text":"<p>               Bases: <code>WirioError</code></p> <p>The exception that is thrown when a service for a parameter of an endpoint cannot be resolved.</p>"},{"location":"api-reference/exceptions/#wirio.exceptions.CircularDependencyError","title":"CircularDependencyError","text":"<p>               Bases: <code>WirioError</code></p> <p>The exception that is thrown when a circular dependency is detected.</p>"},{"location":"api-reference/exceptions/#wirio.exceptions.DirectScopedResolvedFromRootError","title":"DirectScopedResolvedFromRootError","text":"<p>               Bases: <code>WirioError</code></p> <p>The exception that is thrown when a scoped service is resolved directly from the root provider.</p>"},{"location":"api-reference/exceptions/#wirio.exceptions.GeneratorFactoryYieldedSeveralTimesError","title":"GeneratorFactoryYieldedSeveralTimesError","text":"<p>               Bases: <code>WirioError</code></p> <p>The exception that is thrown when a generator factory yields multiple times.</p>"},{"location":"api-reference/exceptions/#wirio.exceptions.InvalidServiceDescriptorError","title":"InvalidServiceDescriptorError","text":"<p>               Bases: <code>WirioError</code></p> <p>The exception that is thrown when a service descriptor is invalid.</p>"},{"location":"api-reference/exceptions/#wirio.exceptions.InvalidServiceKeyTypeError","title":"InvalidServiceKeyTypeError","text":"<p>               Bases: <code>WirioError</code></p> <p>The exception that is thrown when the type of the key used for lookup doesn't match the type in the constructor parameter with the ServiceKey annotation metadata.</p>"},{"location":"api-reference/exceptions/#wirio.exceptions.KeyedServiceAnyKeyUsedToResolveServiceError","title":"KeyedServiceAnyKeyUsedToResolveServiceError","text":"<p>               Bases: <code>WirioError</code></p> <p>The exception that is thrown when KeyedService.AnyKey is used to resolve a single service.</p>"},{"location":"api-reference/exceptions/#wirio.exceptions.NoKeyedServiceRegisteredError","title":"NoKeyedServiceRegisteredError","text":"<p>               Bases: <code>WirioError</code></p> <p>The exception that is thrown when no keyed service is registered for a given type and key.</p>"},{"location":"api-reference/exceptions/#wirio.exceptions.NoKeyedSingletonServiceRegisteredError","title":"NoKeyedSingletonServiceRegisteredError","text":"<p>               Bases: <code>WirioError</code></p> <p>The exception that is thrown when no keyed singleton service is registered for a given type and key.</p>"},{"location":"api-reference/exceptions/#wirio.exceptions.NoServiceRegisteredError","title":"NoServiceRegisteredError","text":"<p>               Bases: <code>WirioError</code></p> <p>The exception that is thrown when no service is registered for a given type.</p>"},{"location":"api-reference/exceptions/#wirio.exceptions.NoSingletonServiceRegisteredError","title":"NoSingletonServiceRegisteredError","text":"<p>               Bases: <code>WirioError</code></p> <p>The exception that is thrown when no singleton service is registered for a given type.</p>"},{"location":"api-reference/exceptions/#wirio.exceptions.NonKeyedDescriptorMisuseError","title":"NonKeyedDescriptorMisuseError","text":"<p>               Bases: <code>WirioError</code></p> <p>The exception that is thrown when a service descriptor is not keyed.</p>"},{"location":"api-reference/exceptions/#wirio.exceptions.ObjectDisposedError","title":"ObjectDisposedError","text":"<p>               Bases: <code>WirioError</code></p> <p>The exception that is thrown when an operation is performed on a disposed object.</p>"},{"location":"api-reference/exceptions/#wirio.exceptions.ScopedInSingletonError","title":"ScopedInSingletonError","text":"<p>               Bases: <code>WirioError</code></p> <p>The exception that is thrown when a scoped service is resolved from a singleton.</p>"},{"location":"api-reference/exceptions/#wirio.exceptions.ScopedResolvedFromRootError","title":"ScopedResolvedFromRootError","text":"<p>               Bases: <code>WirioError</code></p> <p>The exception that is thrown when a scoped service is resolved from the root provider.</p>"},{"location":"api-reference/exceptions/#wirio.exceptions.ServiceContainerNotBuiltError","title":"ServiceContainerNotBuiltError","text":"<p>               Bases: <code>WirioError</code></p> <p>The exception that is thrown when trying to modify the ServiceContainer before it has been built.</p>"},{"location":"api-reference/exceptions/#wirio.exceptions.ServiceDescriptorDoesNotExistError","title":"ServiceDescriptorDoesNotExistError","text":"<p>               Bases: <code>WirioError</code></p> <p>The exception that is thrown when a requested service descriptor doesn't exist.</p>"},{"location":"api-reference/exceptions/#wirio.exceptions.WirioError","title":"WirioError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for Wirio Dependency Injection.</p>"},{"location":"api-reference/host-environment/","title":"HostEnvironment","text":"<p>Provide information about the hosting environment an application is running in.</p>"},{"location":"api-reference/host-environment/#wirio.hosting.host_environment.HostEnvironment.content_root_path","title":"content_root_path  <code>property</code>","text":"<pre><code>content_root_path: str\n</code></pre> <p>Absolute path to the directory that contains the application content files.</p>"},{"location":"api-reference/host-environment/#wirio.hosting.host_environment.HostEnvironment.environment_name","title":"environment_name  <code>property</code>","text":"<pre><code>environment_name: str\n</code></pre> <p>Environment name.</p>"},{"location":"api-reference/host-environment/#wirio.hosting.host_environment.HostEnvironment.is_development","title":"is_development","text":"<pre><code>is_development() -&gt; bool\n</code></pre> <p>Check if the current host environment name is <code>development</code>.</p>"},{"location":"api-reference/host-environment/#wirio.hosting.host_environment.HostEnvironment.is_environment","title":"is_environment","text":"<pre><code>is_environment(environment_name: str) -&gt; bool\n</code></pre> <p>Compare the current host environment name against the specified value.</p>"},{"location":"api-reference/host-environment/#wirio.hosting.host_environment.HostEnvironment.is_local","title":"is_local","text":"<pre><code>is_local() -&gt; bool\n</code></pre> <p>Check if the current host environment name is <code>local</code>.</p>"},{"location":"api-reference/host-environment/#wirio.hosting.host_environment.HostEnvironment.is_production","title":"is_production","text":"<pre><code>is_production() -&gt; bool\n</code></pre> <p>Check if the current host environment name is <code>production</code>.</p>"},{"location":"api-reference/host-environment/#wirio.hosting.host_environment.HostEnvironment.is_staging","title":"is_staging","text":"<pre><code>is_staging() -&gt; bool\n</code></pre> <p>Check if the current host environment name is <code>staging</code>.</p>"},{"location":"api-reference/keyed-service/","title":"KeyedService","text":"<p>Provide static APIs for use with <code>KeyedServiceProvider</code>.</p>"},{"location":"api-reference/service-collection/","title":"ServiceCollection","text":"<p>Collection of service descriptors provided during configuration.</p>"},{"location":"api-reference/service-collection/#wirio.service_collection.ServiceCollection.configuration","title":"configuration  <code>property</code>","text":"<pre><code>configuration: ConfigurationManager\n</code></pre> <p>Collection of configuration providers for the application to compose.</p>"},{"location":"api-reference/service-collection/#wirio.service_collection.ServiceCollection.environment","title":"environment  <code>property</code>","text":"<pre><code>environment: HostEnvironment\n</code></pre> <p>Provide information about the hosting environment an application is running.</p>"},{"location":"api-reference/service-collection/#wirio.service_collection.ServiceCollection.add_auto_activated_keyed_singleton","title":"add_auto_activated_keyed_singleton","text":"<pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None, service_type: type[TService]\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        AsyncGenerator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Generator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Awaitable[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter], TService\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        AsyncGenerator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Generator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Awaitable[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter], TService\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_type: type,\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_instance: object,\n) -&gt; None\n</code></pre> <p>Add an auto-activated keyed singleton service.</p> <p>An auto-activated keyed singleton service is instantiated when the service provider is built (eagerly), rather than when it's first requested (lazily).</p>"},{"location":"api-reference/service-collection/#wirio.service_collection.ServiceCollection.add_auto_activated_singleton","title":"add_auto_activated_singleton","text":"<pre><code>add_auto_activated_singleton(\n    service_type: type[TService],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_singleton(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., AsyncGenerator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_singleton(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., Generator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_singleton(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., Awaitable[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_singleton(\n    service_type: type[TService],\n    implementation_factory: Callable[..., TService],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_singleton(\n    implementation_factory: Callable[\n        ..., AsyncGenerator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_singleton(\n    implementation_factory: Callable[\n        ..., Generator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_singleton(\n    implementation_factory: Callable[\n        ..., Awaitable[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_singleton(\n    implementation_factory: Callable[..., TService],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_singleton(\n    service_type: type[TService], implementation_type: type\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_singleton(\n    service_type: type[TService],\n    implementation_instance: object,\n) -&gt; None\n</code></pre> <p>Add an auto-activated singleton service.</p> <p>An auto-activated singleton service is instantiated when the service provider is built (eagerly), rather than when it's first requested (lazily).</p>"},{"location":"api-reference/service-collection/#wirio.service_collection.ServiceCollection.add_keyed_scoped","title":"add_keyed_scoped","text":"<pre><code>add_keyed_scoped(\n    service_key: TKey | None, service_type: type[TService]\n) -&gt; None\n</code></pre><pre><code>add_keyed_scoped(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        AsyncGenerator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_scoped(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Generator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_scoped(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Awaitable[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_scoped(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter], TService\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_scoped(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        AsyncGenerator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_scoped(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Generator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_scoped(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Awaitable[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_scoped(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter], TService\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_scoped(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_type: type,\n) -&gt; None\n</code></pre> <p>Add a keyed scoped service.</p>"},{"location":"api-reference/service-collection/#wirio.service_collection.ServiceCollection.add_keyed_singleton","title":"add_keyed_singleton","text":"<pre><code>add_keyed_singleton(\n    service_key: TKey | None, service_type: type[TService]\n) -&gt; None\n</code></pre><pre><code>add_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        AsyncGenerator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Generator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Awaitable[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter], TService\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_singleton(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        AsyncGenerator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_singleton(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Generator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_singleton(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Awaitable[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_singleton(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter], TService\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_type: type,\n) -&gt; None\n</code></pre><pre><code>add_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_instance: object,\n) -&gt; None\n</code></pre> <p>Add a keyed singleton service.</p>"},{"location":"api-reference/service-collection/#wirio.service_collection.ServiceCollection.add_keyed_transient","title":"add_keyed_transient","text":"<pre><code>add_keyed_transient(\n    service_key: TKey | None, service_type: type[TService]\n) -&gt; None\n</code></pre><pre><code>add_keyed_transient(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        AsyncGenerator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_transient(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Generator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_transient(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Awaitable[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_transient(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter], TService\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_transient(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        AsyncGenerator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_transient(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Generator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_transient(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Awaitable[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_transient(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter], TService\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_transient(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_type: type,\n) -&gt; None\n</code></pre> <p>Add a keyed transient service.</p>"},{"location":"api-reference/service-collection/#wirio.service_collection.ServiceCollection.add_scoped","title":"add_scoped","text":"<pre><code>add_scoped(service_type: type[TService]) -&gt; None\n</code></pre><pre><code>add_scoped(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., AsyncGenerator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_scoped(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., Generator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_scoped(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., Awaitable[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_scoped(\n    service_type: type[TService],\n    implementation_factory: Callable[..., TService],\n) -&gt; None\n</code></pre><pre><code>add_scoped(\n    implementation_factory: Callable[\n        ..., AsyncGenerator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_scoped(\n    implementation_factory: Callable[\n        ..., Generator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_scoped(\n    implementation_factory: Callable[\n        ..., Awaitable[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_scoped(\n    implementation_factory: Callable[..., TService],\n) -&gt; None\n</code></pre><pre><code>add_scoped(\n    service_type: type[TService], implementation_type: type\n) -&gt; None\n</code></pre> <p>Add a scoped service.</p>"},{"location":"api-reference/service-collection/#wirio.service_collection.ServiceCollection.add_singleton","title":"add_singleton","text":"<pre><code>add_singleton(service_type: type[TService]) -&gt; None\n</code></pre><pre><code>add_singleton(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., AsyncGenerator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_singleton(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., Generator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_singleton(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., Awaitable[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_singleton(\n    service_type: type[TService],\n    implementation_factory: Callable[..., TService],\n) -&gt; None\n</code></pre><pre><code>add_singleton(\n    implementation_factory: Callable[\n        ..., AsyncGenerator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_singleton(\n    implementation_factory: Callable[\n        ..., Generator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_singleton(\n    implementation_factory: Callable[\n        ..., Awaitable[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_singleton(\n    implementation_factory: Callable[..., TService],\n) -&gt; None\n</code></pre><pre><code>add_singleton(\n    service_type: type[TService], implementation_type: type\n) -&gt; None\n</code></pre><pre><code>add_singleton(\n    service_type: type[TService],\n    implementation_instance: object,\n) -&gt; None\n</code></pre> <p>Add a singleton service.</p>"},{"location":"api-reference/service-collection/#wirio.service_collection.ServiceCollection.add_sqlmodel","title":"add_sqlmodel","text":"<pre><code>add_sqlmodel(connection_string: str) -&gt; None\n</code></pre> <p>Add asynchronous SQLModel services.</p>"},{"location":"api-reference/service-collection/#wirio.service_collection.ServiceCollection.add_sync_sqlmodel","title":"add_sync_sqlmodel","text":"<pre><code>add_sync_sqlmodel(connection_string: str) -&gt; None\n</code></pre> <p>Add synchronous SQLModel services.</p>"},{"location":"api-reference/service-collection/#wirio.service_collection.ServiceCollection.add_transient","title":"add_transient","text":"<pre><code>add_transient(service_type: type[TService]) -&gt; None\n</code></pre><pre><code>add_transient(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., AsyncGenerator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_transient(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., Generator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_transient(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., Awaitable[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_transient(\n    service_type: type[TService],\n    implementation_factory: Callable[..., TService],\n) -&gt; None\n</code></pre><pre><code>add_transient(\n    implementation_factory: Callable[\n        ..., AsyncGenerator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_transient(\n    implementation_factory: Callable[\n        ..., Generator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_transient(\n    implementation_factory: Callable[\n        ..., Awaitable[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_transient(\n    implementation_factory: Callable[..., TService],\n) -&gt; None\n</code></pre><pre><code>add_transient(\n    service_type: type[TService], implementation_type: type\n) -&gt; None\n</code></pre> <p>Add a transient service.</p>"},{"location":"api-reference/service-collection/#wirio.service_collection.ServiceCollection.build_service_provider","title":"build_service_provider","text":"<pre><code>build_service_provider(\n    validate_scopes: bool = False,\n    validate_on_build: bool = True,\n) -&gt; ServiceProvider\n</code></pre> <p>Create a :class:<code>ServiceProvider</code> containing services from the this :class:<code>ServiceCollection</code>.</p>"},{"location":"api-reference/service-collection/#wirio.service_collection.ServiceCollection.configure_fastapi","title":"configure_fastapi","text":"<pre><code>configure_fastapi(app: FastAPI) -&gt; None\n</code></pre> <p>Configure the FastAPI application to use dependency injection using the services from this service collection.</p>"},{"location":"api-reference/service-collection/#wirio.service_collection.ServiceCollection.enable_keyed_singleton_auto_activation","title":"enable_keyed_singleton_auto_activation","text":"<pre><code>enable_keyed_singleton_auto_activation(\n    service_key: object | None, service_type: type\n) -&gt; None\n</code></pre> <p>Mark a registered keyed singleton service as auto-activated.</p> <p>An auto-activated keyed singleton service is instantiated when the service provider is built (eagerly), rather than when it's first requested (lazily).</p>"},{"location":"api-reference/service-collection/#wirio.service_collection.ServiceCollection.enable_singleton_auto_activation","title":"enable_singleton_auto_activation","text":"<pre><code>enable_singleton_auto_activation(\n    service_type: type,\n) -&gt; None\n</code></pre> <p>Mark a registered singleton service as auto-activated.</p> <p>An auto-activated singleton service is instantiated when the service provider is built (eagerly), rather than when it's first requested (lazily).</p>"},{"location":"api-reference/service-container/","title":"ServiceContainer","text":"<p>               Bases: <code>ServiceCollection</code>, <code>AbstractAsyncContextManager['ServiceContainer']</code></p> <p>Collection of resolvable services.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.configuration","title":"configuration  <code>property</code>","text":"<pre><code>configuration: ConfigurationManager\n</code></pre> <p>Collection of configuration providers for the application to compose.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.environment","title":"environment  <code>property</code>","text":"<pre><code>environment: HostEnvironment\n</code></pre> <p>Provide information about the hosting environment an application is running.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.add_auto_activated_keyed_singleton","title":"add_auto_activated_keyed_singleton","text":"<pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None, service_type: type[TService]\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        AsyncGenerator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Generator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Awaitable[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter], TService\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        AsyncGenerator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Generator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Awaitable[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter], TService\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_type: type,\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_instance: object,\n) -&gt; None\n</code></pre> <p>Add an auto-activated keyed singleton service.</p> <p>An auto-activated keyed singleton service is instantiated when the service provider is built (eagerly), rather than when it's first requested (lazily).</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.add_auto_activated_singleton","title":"add_auto_activated_singleton","text":"<pre><code>add_auto_activated_singleton(\n    service_type: type[TService],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_singleton(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., AsyncGenerator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_singleton(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., Generator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_singleton(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., Awaitable[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_singleton(\n    service_type: type[TService],\n    implementation_factory: Callable[..., TService],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_singleton(\n    implementation_factory: Callable[\n        ..., AsyncGenerator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_singleton(\n    implementation_factory: Callable[\n        ..., Generator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_singleton(\n    implementation_factory: Callable[\n        ..., Awaitable[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_singleton(\n    implementation_factory: Callable[..., TService],\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_singleton(\n    service_type: type[TService], implementation_type: type\n) -&gt; None\n</code></pre><pre><code>add_auto_activated_singleton(\n    service_type: type[TService],\n    implementation_instance: object,\n) -&gt; None\n</code></pre> <p>Add an auto-activated singleton service.</p> <p>An auto-activated singleton service is instantiated when the service provider is built (eagerly), rather than when it's first requested (lazily).</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.add_keyed_scoped","title":"add_keyed_scoped","text":"<pre><code>add_keyed_scoped(\n    service_key: TKey | None, service_type: type[TService]\n) -&gt; None\n</code></pre><pre><code>add_keyed_scoped(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        AsyncGenerator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_scoped(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Generator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_scoped(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Awaitable[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_scoped(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter], TService\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_scoped(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        AsyncGenerator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_scoped(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Generator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_scoped(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Awaitable[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_scoped(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter], TService\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_scoped(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_type: type,\n) -&gt; None\n</code></pre> <p>Add a keyed scoped service.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.add_keyed_singleton","title":"add_keyed_singleton","text":"<pre><code>add_keyed_singleton(\n    service_key: TKey | None, service_type: type[TService]\n) -&gt; None\n</code></pre><pre><code>add_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        AsyncGenerator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Generator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Awaitable[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter], TService\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_singleton(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        AsyncGenerator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_singleton(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Generator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_singleton(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Awaitable[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_singleton(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter], TService\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_type: type,\n) -&gt; None\n</code></pre><pre><code>add_keyed_singleton(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_instance: object,\n) -&gt; None\n</code></pre> <p>Add a keyed singleton service.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.add_keyed_transient","title":"add_keyed_transient","text":"<pre><code>add_keyed_transient(\n    service_key: TKey | None, service_type: type[TService]\n) -&gt; None\n</code></pre><pre><code>add_keyed_transient(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        AsyncGenerator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_transient(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Generator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_transient(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Awaitable[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_transient(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter], TService\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_transient(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        AsyncGenerator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_transient(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Generator[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_transient(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter],\n        Awaitable[TService],\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_transient(\n    service_key: TKey | None,\n    implementation_factory: Callable[\n        [TKey | None, *TFactoryParameter], TService\n    ],\n) -&gt; None\n</code></pre><pre><code>add_keyed_transient(\n    service_key: TKey | None,\n    service_type: type[TService],\n    implementation_type: type,\n) -&gt; None\n</code></pre> <p>Add a keyed transient service.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.add_scoped","title":"add_scoped","text":"<pre><code>add_scoped(service_type: type[TService]) -&gt; None\n</code></pre><pre><code>add_scoped(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., AsyncGenerator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_scoped(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., Generator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_scoped(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., Awaitable[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_scoped(\n    service_type: type[TService],\n    implementation_factory: Callable[..., TService],\n) -&gt; None\n</code></pre><pre><code>add_scoped(\n    implementation_factory: Callable[\n        ..., AsyncGenerator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_scoped(\n    implementation_factory: Callable[\n        ..., Generator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_scoped(\n    implementation_factory: Callable[\n        ..., Awaitable[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_scoped(\n    implementation_factory: Callable[..., TService],\n) -&gt; None\n</code></pre><pre><code>add_scoped(\n    service_type: type[TService], implementation_type: type\n) -&gt; None\n</code></pre> <p>Add a scoped service.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.add_singleton","title":"add_singleton","text":"<pre><code>add_singleton(service_type: type[TService]) -&gt; None\n</code></pre><pre><code>add_singleton(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., AsyncGenerator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_singleton(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., Generator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_singleton(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., Awaitable[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_singleton(\n    service_type: type[TService],\n    implementation_factory: Callable[..., TService],\n) -&gt; None\n</code></pre><pre><code>add_singleton(\n    implementation_factory: Callable[\n        ..., AsyncGenerator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_singleton(\n    implementation_factory: Callable[\n        ..., Generator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_singleton(\n    implementation_factory: Callable[\n        ..., Awaitable[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_singleton(\n    implementation_factory: Callable[..., TService],\n) -&gt; None\n</code></pre><pre><code>add_singleton(\n    service_type: type[TService], implementation_type: type\n) -&gt; None\n</code></pre><pre><code>add_singleton(\n    service_type: type[TService],\n    implementation_instance: object,\n) -&gt; None\n</code></pre> <p>Add a singleton service.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.add_sqlmodel","title":"add_sqlmodel","text":"<pre><code>add_sqlmodel(connection_string: str) -&gt; None\n</code></pre> <p>Add asynchronous SQLModel services.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.add_sync_sqlmodel","title":"add_sync_sqlmodel","text":"<pre><code>add_sync_sqlmodel(connection_string: str) -&gt; None\n</code></pre> <p>Add synchronous SQLModel services.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.add_transient","title":"add_transient","text":"<pre><code>add_transient(service_type: type[TService]) -&gt; None\n</code></pre><pre><code>add_transient(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., AsyncGenerator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_transient(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., Generator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_transient(\n    service_type: type[TService],\n    implementation_factory: Callable[\n        ..., Awaitable[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_transient(\n    service_type: type[TService],\n    implementation_factory: Callable[..., TService],\n) -&gt; None\n</code></pre><pre><code>add_transient(\n    implementation_factory: Callable[\n        ..., AsyncGenerator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_transient(\n    implementation_factory: Callable[\n        ..., Generator[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_transient(\n    implementation_factory: Callable[\n        ..., Awaitable[TService]\n    ],\n) -&gt; None\n</code></pre><pre><code>add_transient(\n    implementation_factory: Callable[..., TService],\n) -&gt; None\n</code></pre><pre><code>add_transient(\n    service_type: type[TService], implementation_type: type\n) -&gt; None\n</code></pre> <p>Add a transient service.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.build_service_provider","title":"build_service_provider","text":"<pre><code>build_service_provider(\n    validate_scopes: bool = False,\n    validate_on_build: bool = True,\n) -&gt; ServiceProvider\n</code></pre> <p>Create a :class:<code>ServiceProvider</code> containing services from the this :class:<code>ServiceContainer</code>.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.configure_fastapi","title":"configure_fastapi","text":"<pre><code>configure_fastapi(app: FastAPI) -&gt; None\n</code></pre> <p>Configure the FastAPI application to use dependency injection using the services from this service container.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.create_scope","title":"create_scope","text":"<pre><code>create_scope() -&gt; ServiceScope\n</code></pre> <p>Create a new :class:<code>ServiceScope</code> that can be used to resolve scoped services.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.enable_keyed_singleton_auto_activation","title":"enable_keyed_singleton_auto_activation","text":"<pre><code>enable_keyed_singleton_auto_activation(\n    service_key: object | None, service_type: type\n) -&gt; None\n</code></pre> <p>Mark a registered keyed singleton service as auto-activated.</p> <p>An auto-activated keyed singleton service is instantiated when the service provider is built (eagerly), rather than when it's first requested (lazily).</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.enable_singleton_auto_activation","title":"enable_singleton_auto_activation","text":"<pre><code>enable_singleton_auto_activation(\n    service_type: type,\n) -&gt; None\n</code></pre> <p>Mark a registered singleton service as auto-activated.</p> <p>An auto-activated singleton service is instantiated when the service provider is built (eagerly), rather than when it's first requested (lazily).</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.get","title":"get  <code>async</code>","text":"<pre><code>get(service_type: type[TService]) -&gt; TService\n</code></pre> <p>Get service of type <code>TService</code> or raise :class:<code>NoServiceRegisteredError</code>.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.get_all","title":"get_all  <code>async</code>","text":"<pre><code>get_all(service_type: type[TService]) -&gt; Sequence[TService]\n</code></pre> <p>Get all services of type <code>TService</code>.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.get_all_keyed","title":"get_all_keyed  <code>async</code>","text":"<pre><code>get_all_keyed(\n    service_key: object | None, service_type: type[TService]\n) -&gt; Sequence[TService]\n</code></pre> <p>Get all services of type <code>TService</code>.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.get_keyed","title":"get_keyed  <code>async</code>","text":"<pre><code>get_keyed(\n    service_key: object | None, service_type: type[TService]\n) -&gt; TService\n</code></pre> <p>Get service of type <code>TService</code> or raise an error.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.override","title":"override","text":"<pre><code>override(\n    service_type: type,\n    implementation_instance: object | None,\n) -&gt; Generator[None]\n</code></pre> <p>Override a service registration within the context manager scope.</p> <p>It can be used to temporarily replace a service for testing specific scenarios. Don't use it in production.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.override_keyed","title":"override_keyed","text":"<pre><code>override_keyed(\n    service_key: object | None,\n    service_type: type,\n    implementation_instance: object | None,\n) -&gt; Generator[None]\n</code></pre> <p>Override a keyed service registration within the context manager scope.</p> <p>It can be used to temporarily replace a service for testing specific scenarios. Don't use it in production.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.try_get","title":"try_get  <code>async</code>","text":"<pre><code>try_get(service_type: type[TService]) -&gt; TService | None\n</code></pre> <p>Get service of type <code>TService</code> or return <code>None</code>.</p>"},{"location":"api-reference/service-container/#wirio.service_container.ServiceContainer.try_get_keyed","title":"try_get_keyed  <code>async</code>","text":"<pre><code>try_get_keyed(\n    service_key: object | None, service_type: type[TService]\n) -&gt; TService | None\n</code></pre> <p>Get service of type <code>TService</code> or return <code>None</code>.</p>"},{"location":"api-reference/service-provider-is-keyed-service/","title":"ServiceProviderIsKeyedService","text":"<p>               Bases: <code>ServiceProviderIsService</code>, <code>ABC</code></p> <p>Provide methods to determine if the specified service type with the specified service key is available from the :class:<code>BaseServiceProvider</code>.</p>"},{"location":"api-reference/service-provider-is-keyed-service/#wirio.abstractions.service_provider_is_keyed_service.ServiceProviderIsKeyedService.is_keyed_service","title":"is_keyed_service  <code>abstractmethod</code>","text":"<pre><code>is_keyed_service(\n    service_key: object | None, service_type: type\n) -&gt; bool\n</code></pre> <p>Determine if the specified service type with the specified service key is available from the :class:<code>BaseServiceProvider</code>.</p>"},{"location":"api-reference/service-provider-is-keyed-service/#wirio.abstractions.service_provider_is_keyed_service.ServiceProviderIsKeyedService.is_service","title":"is_service  <code>abstractmethod</code>","text":"<pre><code>is_service(service_type: type) -&gt; bool\n</code></pre> <p>Determine if the specified service type is available from the :class:<code>BaseServiceProvider</code>.</p>"},{"location":"api-reference/service-provider-is-service/","title":"ServiceProviderIsService","text":"<p>               Bases: <code>ABC</code></p> <p>Provide methods to determine if the specified service type is available from the :class:<code>BaseServiceProvider</code>.</p>"},{"location":"api-reference/service-provider-is-service/#wirio.abstractions.service_provider_is_service.ServiceProviderIsService.is_service","title":"is_service  <code>abstractmethod</code>","text":"<pre><code>is_service(service_type: type) -&gt; bool\n</code></pre> <p>Determine if the specified service type is available from the :class:<code>BaseServiceProvider</code>.</p>"},{"location":"api-reference/service-provider/","title":"ServiceProvider","text":"<p>               Bases: <code>BaseServiceProvider</code>, <code>AbstractAsyncContextManager['ServiceProvider']</code></p> <p>Provider that resolves services.</p>"},{"location":"api-reference/service-provider/#wirio.service_provider.ServiceProvider.is_fully_initialized","title":"is_fully_initialized  <code>property</code>","text":"<pre><code>is_fully_initialized: bool\n</code></pre> <p>Indicate whether the provider is fully initialized (useful for Jupyter notebooks, which don't work well with context managers).</p>"},{"location":"api-reference/service-provider/#wirio.service_provider.ServiceProvider.aclose","title":"aclose  <code>async</code>","text":"<pre><code>aclose() -&gt; None\n</code></pre> <p>Dispose the service provider and release all resources.</p>"},{"location":"api-reference/service-provider/#wirio.service_provider.ServiceProvider.create_scope","title":"create_scope","text":"<pre><code>create_scope() -&gt; ServiceScope\n</code></pre> <p>Create a new :class:<code>ServiceScope</code> that can be used to resolve scoped services.</p>"},{"location":"api-reference/service-provider/#wirio.service_provider.ServiceProvider.get_keyed_service","title":"get_keyed_service  <code>async</code>","text":"<pre><code>get_keyed_service(\n    service_key: object | None, service_type: type[TService]\n) -&gt; TService | None\n</code></pre> <p>Get service of type <code>TService</code> or return <code>None</code>.</p>"},{"location":"api-reference/service-provider/#wirio.service_provider.ServiceProvider.get_keyed_services","title":"get_keyed_services  <code>async</code>","text":"<pre><code>get_keyed_services(\n    service_key: object | None, service_type: type[TService]\n) -&gt; Sequence[TService]\n</code></pre> <p>Get all services of type <code>TService</code>.</p>"},{"location":"api-reference/service-provider/#wirio.service_provider.ServiceProvider.get_overridden_call_site","title":"get_overridden_call_site","text":"<pre><code>get_overridden_call_site(\n    service_identifier: ServiceIdentifier,\n) -&gt; ServiceCallSite | None\n</code></pre> <p>Retrieve the override call site for a given identifier if present.</p>"},{"location":"api-reference/service-provider/#wirio.service_provider.ServiceProvider.get_required_keyed_service","title":"get_required_keyed_service  <code>async</code>","text":"<pre><code>get_required_keyed_service(\n    service_key: object | None, service_type: type[TService]\n) -&gt; TService\n</code></pre> <p>Get service of type <code>TService</code> or raise an error.</p>"},{"location":"api-reference/service-provider/#wirio.service_provider.ServiceProvider.get_required_service","title":"get_required_service  <code>async</code>","text":"<pre><code>get_required_service(\n    service_type: type[TService],\n) -&gt; TService\n</code></pre> <p>Get service of type <code>TService</code> or raise :class:<code>NoServiceRegisteredError</code>.</p>"},{"location":"api-reference/service-provider/#wirio.service_provider.ServiceProvider.get_service","title":"get_service  <code>async</code>","text":"<pre><code>get_service(\n    service_type: type[TService],\n) -&gt; TService | None\n</code></pre> <p>Get service of type <code>TService</code> or return <code>None</code>.</p>"},{"location":"api-reference/service-provider/#wirio.service_provider.ServiceProvider.get_services","title":"get_services  <code>async</code>","text":"<pre><code>get_services(\n    service_type: type[TService],\n) -&gt; Sequence[TService]\n</code></pre> <p>Get all services of type <code>TService</code>.</p>"},{"location":"api-reference/service-provider/#wirio.service_provider.ServiceProvider.override_keyed_service","title":"override_keyed_service","text":"<pre><code>override_keyed_service(\n    service_key: object | None,\n    service_type: type,\n    implementation_instance: object | None,\n) -&gt; Generator[None]\n</code></pre> <p>Override a keyed service registration within the context manager scope.</p> <p>It can be used to temporarily replace a service for testing specific scenarios. Don't use it in production.</p>"},{"location":"api-reference/service-provider/#wirio.service_provider.ServiceProvider.override_service","title":"override_service","text":"<pre><code>override_service(\n    service_type: type,\n    implementation_instance: object | None,\n) -&gt; Generator[None]\n</code></pre> <p>Override a service registration within the context manager scope.</p> <p>It can be used to temporarily replace a service for testing specific scenarios. Don't use it in production.</p>"},{"location":"api-reference/service-scope-factory/","title":"ServiceScopeFactory","text":"<p>               Bases: <code>ABC</code></p> <p>Create instances of :class:<code>ServiceScope</code>, which is used to create services within a scope.</p>"},{"location":"api-reference/service-scope-factory/#wirio.abstractions.service_scope_factory.ServiceScopeFactory.create_scope","title":"create_scope  <code>abstractmethod</code>","text":"<pre><code>create_scope() -&gt; ServiceScope\n</code></pre> <p>Create a :class:<code>ServiceScope</code> that contains a :class:<code>ServiceProvider</code> used to resolve dependencies from a newly created scope.</p>"},{"location":"api-reference/service-scope/","title":"ServiceScope","text":"<p>               Bases: <code>AbstractAsyncContextManager['ServiceScope']</code>, <code>ABC</code></p> <p>Defines a disposable service scope.</p> <p>The aexit method ends the scope lifetime. Once called, any scoped services that have been resolved from ServiceProvider will be disposed.</p>"},{"location":"api-reference/service-scope/#wirio.abstractions.service_scope.ServiceScope.service_provider","title":"service_provider  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>service_provider: BaseServiceProvider\n</code></pre> <p>Gets the :class:<code>BaseServiceProvider</code> used to resolve dependencies from the scope.</p>"},{"location":"api-reference/service-scope/#wirio.abstractions.service_scope.ServiceScope.get_keyed_service","title":"get_keyed_service  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_keyed_service(\n    service_key: object | None, service_type: type[TService]\n) -&gt; TService | None\n</code></pre> <p>Get service of type <code>TService</code> or return <code>None</code>.</p>"},{"location":"api-reference/service-scope/#wirio.abstractions.service_scope.ServiceScope.get_keyed_services","title":"get_keyed_services  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_keyed_services(\n    service_key: object | None, service_type: type[TService]\n) -&gt; Sequence[TService]\n</code></pre> <p>Get all services of type <code>TService</code>.</p>"},{"location":"api-reference/service-scope/#wirio.abstractions.service_scope.ServiceScope.get_required_keyed_service","title":"get_required_keyed_service  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_required_keyed_service(\n    service_key: object | None, service_type: type[TService]\n) -&gt; TService\n</code></pre> <p>Get service of type <code>TService</code> or raise an error.</p>"},{"location":"api-reference/service-scope/#wirio.abstractions.service_scope.ServiceScope.get_required_service","title":"get_required_service  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_required_service(\n    service_type: type[TService],\n) -&gt; TService\n</code></pre> <p>Get service of type <code>TService</code> or raise :class:<code>NoServiceRegisteredError</code>.</p>"},{"location":"api-reference/service-scope/#wirio.abstractions.service_scope.ServiceScope.get_service","title":"get_service  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_service(\n    service_type: type[TService],\n) -&gt; TService | None\n</code></pre> <p>Get service of type <code>TService</code> or return <code>None</code>.</p>"},{"location":"api-reference/service-scope/#wirio.abstractions.service_scope.ServiceScope.get_services","title":"get_services  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_services(\n    service_type: type[TService],\n) -&gt; Sequence[TService]\n</code></pre> <p>Get all services of type <code>TService</code>.</p>"},{"location":"core-concepts/async-first-design/","title":"Async-first design","text":""},{"location":"core-concepts/async-first-design/#issue-to-solve","title":"Issue to solve","text":"<p>Using libraries with IO operations (databases, files, LLMs, HTTP...), we can encounter several cases:</p> <ul> <li>Libraries that provide both synchronous and asynchronous APIs, and we have to find out which one to use.</li> <li>Libraries that are synchronous, having to use <code>asyncio.to_thread</code> or similar techniques to run them without blocking the event loop.</li> <li>Libraries that are asynchronous.</li> </ul> <p>Using synchronous IO code blocks the event loop, leading to performance issues and a poor user experience.</p> <p>Regarding the use of those libraries, we need to know whether we need to use an async context manager, a sync context manager, or no context manager at all. This adds cognitive load and increases the chances of making mistakes.</p>"},{"location":"core-concepts/async-first-design/#why-a-synchronous-design-is-not-enough","title":"Why a synchronous design is not enough","text":"<p>We can add synchronous services to a synchronous dependency injection library, but at the moment we need to add asynchronous services, they'll crash because they can't be instantiated correctly (<code>__aenter__</code>) or we'll need to use workarounds such as creating a thread to run async code, which adds performance overhead and complexity.</p> <p>At the end, if a dependency injection library is not async-first, in order to support sync and async code, it'll introduce performance issues or duplicate the codebase (async must be propagated, and the locking mechanisms and logic change).</p> <p>So, if we want a dependency injection library that works well with async code and can resolve both synchronous and asynchronous, it must be designed with async in mind from the beginning.</p>"},{"location":"core-concepts/async-first-design/#wirios-async-first-design","title":"Wirio's async-first design","text":"<p>Wirio is designed to be async-first, meaning that it can handle both synchronous and asynchronous services seamlessly.</p>"},{"location":"core-concepts/configuration/","title":"Configuration","text":"<p>Wirio provides a built-in configuration system for loading settings. We can read values from multiple sources (such as JSON files and environment variables) and compose them using a clear precedence order where newer sources override older ones.</p>"},{"location":"core-concepts/configuration/#quickstart","title":"Quickstart","text":"<p>Define a settings model and read it from <code>services.configuration</code>:</p> <pre><code>from pydantic import BaseModel\nfrom wirio.service_collection import ServiceCollection\n\n\nclass ApplicationSettings(BaseModel):\n    app_name: str\n    port: int\n\n\nservices = ServiceCollection()\nsettings = services.configuration[ApplicationSettings]\n</code></pre> <p>Wirio maps model field names to configuration keys using snake case conventions.</p> <p>For example, the <code>APP_NAME</code> environment variable is read as <code>app_name</code>.</p>"},{"location":"core-concepts/configuration/#defaults-and-required-values","title":"Defaults and required values","text":"<p>When building a settings model, if a field has a default value, that default is used when no value is found.</p> <pre><code>from pydantic import BaseModel\n\n\nclass ApplicationSettings(BaseModel):\n    app_name: str\n    port: int | None = None\n</code></pre> <p>In this example, <code>port</code> defaults to <code>None</code> when not present.</p>"},{"location":"core-concepts/configuration/#order-of-precedence","title":"Order of precedence","text":"<p><code>ConfigurationManager</code> supports multiple sources, and the latest added source wins.</p> <p>When the same key exists in more than one source, Wirio resolves the value from the last source that contains that key.</p> <p>Default priority (highest to lowest):</p> <ol> <li>Environment variables</li> <li><code>appsettings.{environment}.json</code></li> <li><code>appsettings.json</code></li> </ol> <p>This lets us define base values in <code>appsettings.json</code>, override per environment in <code>appsettings.{environment}.json</code>, and finally override specific keys via environment variables.</p>"},{"location":"core-concepts/configuration/#accessing-configuration-in-factories","title":"Accessing configuration in factories","text":"<p>A common pattern is reading typed settings inside a service factory:</p> <pre><code>from pydantic import BaseModel\nfrom wirio.service_collection import ServiceCollection\n\n\nclass ApplicationSettings(BaseModel):\n    database_connection_string: str\n\n\nclass DatabaseClient:\n    def __init__(self, connection_string: str) -&gt; None:\n        self.connection_string = connection_string\n\n\nservices = ServiceCollection()\n\n\ndef inject_database_client() -&gt; DatabaseClient:\n    settings = services.configuration[ApplicationSettings]\n    return DatabaseClient(settings.database_connection_string)\n\n\nservices.add_singleton(inject_database_client)\n</code></pre>"},{"location":"core-concepts/environments/","title":"Environments","text":""},{"location":"core-concepts/environments/#overview","title":"Overview","text":"<p>Wirio exposes the current application environment through <code>services.environment</code>.</p> <p>This is useful when we want to register different services, enable diagnostics, or choose configuration behavior based on where the app is running.</p>"},{"location":"core-concepts/environments/#environment-source","title":"Environment source","text":"<p>Wirio reads the environment from the <code>WIRIO_ENVIRONMENT</code> environment variable.</p> <p>If the variable is not defined, Wirio defaults to <code>local</code>.</p> <p>Supported values by default are:</p> <ul> <li><code>local</code></li> <li><code>development</code></li> <li><code>staging</code></li> <li><code>production</code></li> </ul>"},{"location":"core-concepts/environments/#reading-the-current-environment","title":"Reading the current environment","text":"<pre><code>from wirio.service_collection import ServiceCollection\n\n\nservices = ServiceCollection()\n\nprint(services.environment.environment_name)\n</code></pre>"},{"location":"core-concepts/environments/#environment-checks","title":"Environment checks","text":"<p>Use the built-in helper methods when we only need a boolean check:</p> <pre><code>from wirio.service_collection import ServiceCollection\n\n\nservices = ServiceCollection()\n\nif services.environment.is_local():\n    print(\"Running in local\")\n\nif services.environment.is_development():\n    print(\"Running in development\")\n\nif services.environment.is_staging():\n    print(\"Running in staging\")\n\nif services.environment.is_production():\n    print(\"Running in production\")\n</code></pre> <p>For custom values, use <code>is_environment(...)</code>:</p> <pre><code>from wirio.service_collection import ServiceCollection\n\n\nservices = ServiceCollection()\n\nif services.environment.is_environment(\"uat\"):\n    print(\"UAT behavior\")\n</code></pre>"},{"location":"core-concepts/factories/","title":"Factories","text":""},{"location":"core-concepts/factories/#quickstart","title":"Quickstart","text":"<p>Sometimes, a service cannot be created automatically. For example, consider <code>DatabaseClient</code>, which requires a connection string:</p> <pre><code>class DatabaseClient:\n    def __init__(self, connection_string: str) -&gt; None:\n        pass\n</code></pre> <p><code>str</code> is too generic to register as a service. We could have other strings registered (e.g., API URL, logging level, service bus queue), and it wouldn't be clear which string is the connection string.</p> <p>The connection string could come from anywhere: an environment variable, a config file, a secrets manager, etc.</p> <p>Let's say we want to get the connection string from an environment variable. We can create a factory function that reads the environment variable and returns <code>DatabaseClient</code>, the service we want to register, and then we can register that factory as a service:</p> <pre><code>def inject_database_client() -&gt; DatabaseClient:\n    return DatabaseClient(\n        connection_string=os.environ[\"DATABASE_CONNECTION_STRING\"]\n    )\n\nservices.add_transient(inject_database_client)\n</code></pre> <p>Wirio will automatically resolve the dependencies of the factory (in this case, none, because the factory has no parameters) and use the returned type (<code>DatabaseClient</code>) as the service type to register.</p> <p>Note</p> <p>The factory can be async if we need to perform asynchronous operations during service creation, such as fetching secrets or performing I/O operations.</p>"},{"location":"core-concepts/factories/#dependencies","title":"Dependencies","text":"<p>We've seen that we can register services by providing a factory, but what if our factory needs dependencies itself? No problem! Just add them as parameters to the factory, and Wirio will resolve them for us.</p> <p>For example, the typical approach to manage settings is to centralize them in an <code>ApplicationSettings</code> class, which we register as a singleton service:</p> <pre><code>from pydantic_settings import BaseSettings\n\n\nclass ApplicationSettings(BaseSettings):\n    database_connection_string: str\n\nservices.add_singleton(ApplicationSettings, ApplicationSettings())\n</code></pre> <p>Then, we can inject <code>ApplicationSettings</code> into our factory to create the <code>DatabaseClient</code>:</p> <pre><code>def inject_database_client(application_settings: ApplicationSettings) -&gt; DatabaseClient:\n    return DatabaseClient(\n        connection_string=application_settings.database_connection_string\n    )\n\nservices.add_transient(inject_database_client)\n</code></pre>"},{"location":"core-concepts/factories/#generator-factories","title":"Generator factories","text":"<p>Wirio is smart and doesn't need the boilerplate of creating generator factories, but in order to support the edge case where we want to use a library that provides custom methods instead of context manager support, Wirio can handle that as well.</p> <pre><code>async def inject_database_client(application_settings: ApplicationSettings) -&gt; AsyncGenerator[DatabaseClient]:\n    database_client = DatabaseClient(application_settings.database_connection_string)\n\n    try:\n        await database_client.connect()\n        yield database_client\n    finally:\n        await database_client.aclose()\n\n\nservices.add_transient(inject_database_client)\n</code></pre>"},{"location":"core-concepts/lifetimes/","title":"Lifetimes","text":"<p>Lifetimes define how long a service instance lives and how it is shared. Wirio supports three lifetimes:</p> <ul> <li><code>Transient</code>: A new instance is created every time the service is requested. Examples: Services without state, workflows, repositories, service clients...</li> <li><code>Singleton</code>: The same instance is used every time the service is requested. Examples: Settings (<code>pydantic-settings</code>), machine learning models, database connection pools, caches.</li> <li><code>Scoped</code>: A new instance is created for each new scope, but the same instance is returned within the same scope. Examples: Database clients, unit of work.</li> </ul>"},{"location":"core-concepts/pluggable-architecture/","title":"Pluggable architecture","text":""},{"location":"core-concepts/pluggable-architecture/#overview","title":"Overview","text":"<p>Wirio follows the same extension-friendly design that ASP.NET Core popularized. Rather than hiding registrations behind a monolithic container, the library exposes the <code>ServiceCollection</code> and encourages features to be layered through small, self-contained modules. This lets applications opt into only the capabilities they need while keeping configurations declarative and easy to reason about.</p>"},{"location":"core-concepts/pluggable-architecture/#servicecollection-as-the-composition-root","title":"ServiceCollection as the Composition Root","text":"<ul> <li><code>ServiceCollection</code> is the single aggregation point for all services. Each feature contributes registrations by receiving an instance of the collection and calling standard helpers.</li> <li>The resulting graph is immutable once <code>build_service_provider()</code> is invoked, ensuring the runtime container is predictable and thread-safe.</li> <li>Because everything flows through the collection, reusable packages can add services without assuming how the host application instantiates the provider.</li> </ul>"},{"location":"core-concepts/pluggable-architecture/#servicecollection-extensions-add_-helpers","title":"ServiceCollection extensions (<code>add_*</code> helpers)","text":"<p>We, or the own libraries we use, can provide functions that accept a <code>ServiceCollection</code> and register the required services. For example, a logging package might expose an <code>add_logging</code> function, providing good defaults and injectable services:</p> <pre><code>def add_logging(services: ServiceCollection) -&gt; None:\n    services.add_singleton(LoggerFactory, DefaultLoggerFactory)\n    services.add_transient(Logger)\n</code></pre> <p>Similarly, an observability package could offer an <code>add_observability</code> function:</p> <pre><code>def add_observability(services: ServiceCollection) -&gt; None:\n    services.add_singleton(MetricsClient, PrometheusMetricsClient)\n    services.add_singleton(Tracer, OtelTracer)\n</code></pre> <p>The <code>sqlmodel</code> library might provide by default the <code>add_sqlmodel</code> extension, which sets up SQLModel, so all the typical boilerplate is handled for us with just a single line of code:</p> <pre><code>def add_sqlmodel(services: ServiceCollection, connection_string: str) -&gt; None:\n    def inject_async_engine() -&gt; AsyncEngine:\n        return create_async_engine(connection_string)\n\n    services.add_singleton(inject_async_engine)\n\n    def inject_async_sessionmaker(\n        async_engine: AsyncEngine,\n    ) -&gt; async_sessionmaker[AsyncSession]:\n        return async_sessionmaker(\n            async_engine, class_=AsyncSession, expire_on_commit=False\n        )\n\n    services.add_singleton(inject_async_sessionmaker)\n\n    def inject_async_session(\n        async_sessionmaker: async_sessionmaker[AsyncSession],\n    ) -&gt; AsyncSession:\n        return async_sessionmaker()\n\n    services.add_transient(inject_async_session)\n</code></pre> <p>And then our <code>main.py</code> would be:</p> <pre><code>services = ServiceCollection()\nadd_logging(services)\nadd_observability(services)\nadd_sqlmodel(services, connection_string=\"...\")\n</code></pre> <p>In a real application, we might have:</p> <pre><code>services = ServiceCollection()\napplication_settings = ApplicationSettings()\nservices.add_singleton(ApplicationSettings, application_settings)\nadd_logging(services)\nadd_observability(services)\nadd_sqlmodel(\n    services,\n    connection_string=application_settings.database_connection_string,\n)\n</code></pre> <p>As a note, if we created our own <code>add_sqlmodel</code> extension, the code would be even shorter because we can reuse the <code>ApplicationSettings</code> instance already registered in <code>ServiceCollection</code>:</p> <pre><code>def add_sqlmodel(services: ServiceCollection) -&gt; None:\n    def inject_async_engine(application_settings: ApplicationSettings) -&gt; AsyncEngine:\n        return create_async_engine(application_settings.postgresql_connection_string)\n\n    ...\n\n\nadd_sqlmodel(services)\n</code></pre> <p>We could also have the following extensions:</p> <pre><code>add_api_versioning(services)\nadd_caching(services)\nadd_cors(services)\nadd_identity(services)\nadd_cookie_policy(services, ...)\nadd_authorization(services, ...)\n</code></pre>"},{"location":"core-concepts/pluggable-architecture/#why-not-a-container-subclass","title":"Why not a Container subclass?","text":"<p>Other libraries embrace a container-class API: we extend a <code>Container</code>, override methods, or mutate attributes to register services. That style works, but it comes with trade-offs that Wirio intentionally avoids:</p> <ul> <li>Interoperability: Both approaches technically work across frameworks, but the collection style keeps things primitive (just create an instance and start registering). Container subclasses introduce class-level state, overridden hooks, and metaclass magic that become friction points when we try to share the same container between, say, a CLI bootstrapper and an async worker, or application code and test cases.</li> <li>Composability: Collection-first helpers (<code>add_logging</code>, <code>add_sqlmodel</code>, etc.) compose like ordinary functions. Container subclasses tend to accumulate registration logic across inheritance hierarchies, making it harder to cherry-pick modules or share them between apps.</li> <li>Predictability: Once <code>build_service_provider()</code> runs, the provider is sealed. Container-class APIs often allow late mutation or rely on attribute access magic, which can hide ordering bugs.</li> <li>Testability: Tests can spin up a fresh <code>ServiceCollection</code>, register or override fakes, and build a provider in a few lines. When registrations sit inside container subclasses, swapping implementations usually means subclassing again or using custom hooks.</li> </ul> <p>In short, the <code>ServiceCollection</code> model mirrors ASP.NET Core's ergonomics while staying idiomatic to Python: no inheritance requirements, just functional building blocks we can plug together as needed.</p>"},{"location":"core-concepts/pluggable-architecture/#how-to-structure-feature-packages","title":"How to structure feature packages","text":"<ol> <li>Expose a single public entry point (for example, <code>def add_feature(services: ServiceCollection, **options) -&gt; None</code>).</li> <li>Register abstractions, not concrete types. Use interfaces in shared libraries, so consumers can replace implementations when needed.</li> <li>Keep configuration explicit. Pass options via parameters or small dataclasses instead of global state.</li> <li>Document prerequisites. If <code>add_sqlmodel</code> expects a configured <code>Engine</code>, accept it as a parameter or register a factory that builds one from provided settings.</li> </ol>"},{"location":"core-concepts/pluggable-architecture/#putting-it-together","title":"Putting it together","text":"<p>The end result is a plug-and-play ecosystem: logging, observability, data stores, caching, and custom application modules all plug into <code>ServiceCollection</code> the same way. This symmetry makes it trivial to port patterns from ASP.NET Core DI, reuse mental models, and share modules across Python services that embrace the dependency injection container.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<pre><code>uv add wirio\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":""},{"location":"getting-started/quickstart/#define-dependencies","title":"Define dependencies","text":"<p>To showcase the basics of Wirio, we will create a service collection able to resolve the following:</p> <ul> <li><code>EmailService</code>: A simple service with no dependencies.</li> <li><code>UserService</code>: A service depending on <code>EmailService</code>.</li> </ul> <pre><code>class EmailService:\n    pass\n\n\nclass UserService:\n    def __init__(self, email_service: EmailService) -&gt; None:\n        self.email_service = email_service\n</code></pre>"},{"location":"getting-started/quickstart/#register-services","title":"Register services","text":"<p>The next step is to create the service collection and register the dependencies we just defined.</p> main.py<pre><code>from wirio.service_collection import ServiceCollection\n\nservices = ServiceCollection()\nservices.add_transient(EmailService)  # (1)!\nservices.add_transient(UserService)\n</code></pre> <ol> <li>Both services are registered as transient, meaning a new instance will be created each time they're requested</li> </ol> <p>We'll use <code>.add_X</code> depending on the desired lifetime. For example: <code>.add_transient</code> for transient services, <code>.add_singleton</code> for singleton services and <code>.add_scoped</code> for scoped services.</p>"},{"location":"getting-started/quickstart/#use","title":"Use","text":"<p>Finally, we convert the service collection into a service provider, which will validate and build the dependency graph, and we'll be able to request instances from it.</p> FastAPIConsole applicationJupyter notebook <p>To resolve dependencies from the service provider, we annotate the parameter with the type we want to resolve.</p> main.py<pre><code>from wirio.annotations import FromServices\n\n@app.post(\"/users\")\nasync def create_user(\n    user_service: Annotated[UserService, FromServices()],\n) -&gt; None:\n    pass\n\nservices.configure_fastapi(app)  # (1)!\n</code></pre> <ol> <li>This will configure FastAPI to use Wirio's dependency injection</li> </ol> <p>To resolve dependencies from the service provider, we call <code>get_required_service</code> with the type we want to resolve.</p> main.py<pre><code>async with services.build_service_provider() as service_provider:\n    user_service = await service_provider.get_required_service(UserService)\n</code></pre> <p>To resolve dependencies from the service provider, we call <code>get_required_service</code> with the type we want to resolve.</p> notebook.ipynb<pre><code>service_provider = services.build_service_provider()\nuser_service = await service_provider.get_required_service(UserService)\n</code></pre>"},{"location":"getting-started/quickstart/#full-code","title":"Full code","text":"FastAPIConsole applicationJupyter notebook <pre><code>from typing import Annotated\n\nfrom fastapi import FastAPI\n\nfrom wirio.annotations import FromServices\nfrom wirio.service_collection import ServiceCollection\n\n\nclass EmailService:\n    pass\n\n\nclass UserService:\n    def __init__(self, email_service: EmailService) -&gt; None:\n        self.email_service = email_service\n\n    async def create_user(self) -&gt; None:\n        pass\n\n\napp = FastAPI()\n\n\n@app.post(\"/users\")\nasync def create_user(\n    user_service: Annotated[UserService, FromServices()],\n) -&gt; None:\n    pass\n\n\nservices = ServiceCollection()\nservices.configure_fastapi(app)\nservices.add_transient(EmailService)\nservices.add_transient(UserService)\n</code></pre> <pre><code>import asyncio\n\nfrom wirio.service_collection import ServiceCollection\n\nclass EmailService:\n    pass\n\nclass UserService:\n    def __init__(self, email_service: EmailService) -&gt; None:\n        self.email_service = email_service\n\n        async def create_user(self) -&gt; None:\n            pass\n\n\nasync def main() -&gt; None:\n    services = ServiceCollection()\n    services.add_transient(EmailService)\n    services.add_transient(UserService)\n\n    async with services.build_service_provider() as service_provider:\n        user_service = await service_provider.get_required_service(UserService)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <pre><code>from main import services\n\nservice_provider = services.build_service_provider()\nuser_service = await service_provider.get_required_service(UserService)\n</code></pre>"},{"location":"getting-started/quickstart/#test","title":"Test","text":"<p>We can substitute dependencies on the fly meanwhile the context manager is active.</p> <pre><code>with service_provider.override_service(EmailService, email_service_mock):\n    user_service = await service_provider.get_required_service(UserService)\n</code></pre> <p>For more information, check the testing documentation.</p>"},{"location":"integrations/fastapi/","title":"FastAPI integration","text":""},{"location":"integrations/fastapi/#benefits","title":"Benefits","text":"<ul> <li>Use Wirio's dependency injection in FastAPI.</li> <li>Use FastAPI with a framework-agnostic dependency injection.</li> <li>Easily testable services.</li> <li>Transparent integration instead of referencing module-based singletons.</li> </ul>"},{"location":"integrations/fastapi/#installation","title":"Installation","text":"<p>To use the FastAPI integration, add the <code>fastapi</code> extra to automatically install the required compatible dependencies.</p> <pre><code>uv add wirio[fastapi]\n</code></pre>"},{"location":"integrations/fastapi/#quickstart","title":"Quickstart","text":"<pre><code>from typing import Annotated\n\nfrom fastapi import FastAPI\n\nfrom wirio.annotations import FromServices\nfrom wirio.service_collection import ServiceCollection\n\n\nclass EmailService:\n    pass\n\n\nclass UserService:\n    def __init__(self, email_service: EmailService) -&gt; None:\n        self.email_service = email_service\n\n    async def create_user(self) -&gt; None:\n        pass\n\n\napp = FastAPI()\n\n\n@app.post(\"/users\")\nasync def create_user(\n    user_service: Annotated[UserService, FromServices()],  # (1)!\n) -&gt; None:\n    pass\n\n\nservices = ServiceCollection()\nservices.configure_fastapi(app)  # (2)!\nservices.add_transient(EmailService)\nservices.add_transient(UserService)\n</code></pre> <ol> <li>Annotate the parameter with the type to resolve</li> <li>This will configure FastAPI to use Wirio's dependency injection</li> </ol>"},{"location":"integrations/fastapi/#testing","title":"Testing","text":"<p>Information available here.</p>"},{"location":"integrations/sqlmodel/","title":"SQLModel integration","text":""},{"location":"integrations/sqlmodel/#benefits","title":"Benefits","text":"<p>We had to dive into the docs every time to set up SQLModel: multiple ways to initialize it, context managers everywhere, different settings for sync and async.</p> <p>Setting up SQLModel should take seconds, and be configured with the best practices by just adding a single line of code.</p> <p>Some of the SQLModel integration benefits:</p> <ul> <li>Automatic registration of SQLModel services.</li> <li>Recommended configuration by default.</li> <li>No context managers.</li> <li>Consistent and recommended lifetime management out-of-the-box.</li> </ul>"},{"location":"integrations/sqlmodel/#installation","title":"Installation","text":"<p>To use the SQLModel integration, add the <code>sqlmodel</code> extra to automatically install the required compatible dependencies.</p> <pre><code>uv add wirio[sqlmodel]\n</code></pre>"},{"location":"integrations/sqlmodel/#asynchronous-setup-recommended","title":"Asynchronous setup (recommended)","text":"<p><code>add_sqlmodel</code> configures SQLModel for asynchronous workloads and registers the following services:</p> <ul> <li><code>AsyncEngine</code> as singleton</li> <li><code>async_sessionmaker[AsyncSession]</code> as singleton</li> <li><code>AsyncSession</code> as scoped</li> </ul> <p>We only have to provide the connection string, and Wirio will take care of the rest.</p> <pre><code>services = ServiceCollection()\nservices.add_sqlmodel(\n    \"postgresql+asyncpg://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;database&gt;\"\n)\n</code></pre> <p>We're using the <code>asyncpg</code> driver (<code>uv add asyncpg</code>) in the connection string, but we can use any driver supported by SQLModel.</p>"},{"location":"integrations/sqlmodel/#imports-to-resolve-registered-async-services","title":"Imports to resolve registered async services","text":"<p>It's important to import the correct types to resolve the registered services.</p> <pre><code>from sqlalchemy.ext.asyncio import AsyncEngine, async_sessionmaker\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n</code></pre> <p>Then, we can use it in the easiest way possible:</p> <pre><code>class UserService:\n    def __init__(self, sql_session: AsyncSession) -&gt; None:\n        self.sql_session = sql_session\n</code></pre>"},{"location":"integrations/sqlmodel/#synchronous-setup","title":"Synchronous setup","text":"<p><code>add_sync_sqlmodel</code> configures SQLModel for synchronous workloads and registers the following services:</p> <ul> <li><code>Engine</code> as singleton</li> <li><code>sessionmaker[Session]</code> as singleton</li> <li><code>Session</code> as scoped</li> </ul> <p>We only have to provide the connection string, and Wirio will take care of the rest.</p> <pre><code>services = ServiceCollection()\nservices.add_sync_sqlmodel(\n    \"postgresql+psycopg2://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;database&gt;\"\n)\n</code></pre> <p>We're using the <code>psycopg2</code> driver (<code>uv add psycopg2-binary</code>) in the connection string, but we can use any driver supported by SQLModel.</p>"},{"location":"integrations/sqlmodel/#imports-to-resolve-registered-synchronous-services","title":"Imports to resolve registered synchronous services","text":"<p>It's important to import the correct types to resolve the registered services.</p> <pre><code>from sqlalchemy import Engine\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlmodel import Session\n</code></pre> <p>Then, we can use it in the easiest way possible:</p> <pre><code>class UserService:\n    def __init__(self, sql_session: Session):\n        self.sql_session = sql_session\n</code></pre>"},{"location":"other/changelogs/","title":"Changelogs","text":"<p>Available here.</p>"}]}